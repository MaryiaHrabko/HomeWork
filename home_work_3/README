1. Создать класс WithoutCalculatorMain в котором необходимо посчитать следующие выражения:
	1.1 4.1 + 15 * 7 + (28 / 5) ^ 2.
	Вывести сохранённый результат в консоль. Внимание, знак "^" обозначает возведение в степень.
>> runners.WithoutCalculatorMain

2. Создать класс CalculatorWithOperator.
	2.1 Все методы объявленные в данном классе НЕ статические (не имеют модификатор static).
	2.2 В классе должны присутствовать математические методы:
		2.2.1 4 базовых математических метода (деление, умножение, вычитание, сложение)
		каждый из этих методов должен принимать два параметра (определитесь с их типами)
		и должны возвращать результат (определиться с возвращаемым типом результата) при помощи ключевого слово return.
		2.2.2 3 метода (Возведение в целую степень дробного положительного числа, Модуль числа, Квадратный корень из числа).
	2.3 В методах можно использовать любые арифметические операторы.
	2.4 Использование библиотеки Math ЗАПРЕЩЕНО! (кроме извлечения корня).
	Если у Вас плохо с математикой, то для реализации метода "Квадратный корень из числа" можно воспользоваться библиотекой Math.
	2.5 Создать класс CalculatorWithOperatorMain в котором будет точка входа (main метод).
	В main методе требуется создать экземпляр калькулятора
	и используя методы из данного экземпляра посчитать выражения из задания 1. Вывести в консоль результат.
>> simple.CalculatorWithOperator
>> runners.CalculatorWithOperatorMain

3. Создать класс CalculatorWithMathCopy.
	3.1 Все методы объявленные в данном классе НЕ статические (не имеют модификатор static).
	3.2 В классе должны присутствовать математические методы:
		3.2.1 4 базовых математических метода (деление, умножение, вычитание, сложение).
		Скопировать базовые математические операции из CalculatorWithOperator.
		3.2.2 3 метода (Возведение в целую степень дробного положительного числа, Модуль числа, Корень из числа).
		Данные методы должны содержать в своём теле вызов библиотеки Math и возврат полученного результата.
	3.3 Создать класс CalculatorWithMathCopyMain в котором будет точка входа (main метод).
	В main методе требуется создать экземпляр калькулятора
	и используя методы из данного экземпляра посчитать выражения из задания 1. Вывести в консоль результат.
>> simple.CalculatorWithMathCopy
>> runners.CalculatorWithMathCopyMain

4. Создать класс CalculatorWithMathExtends.
	4.1 Все методы объявленные в данном классе НЕ статические (не имеют модификатор static).
	4.2 Данный класс должен наследовать класс CalculatorWithOperator.
	4.3 Условия:
		4.3.1 4 базовых математических метода (деление, умножение, вычитание, сложение)
		НЕ ДОЛЖНЫ быть объявлены напрямую в классе, а должны быть унаследованы от родительского класса (4.2).
		4.3.2 3 метода (Возведение в целую степень дробного положительного числа, Модуль числа, Корень из числа).
		Данные методы должны ПЕРЕОПРЕДЕЛЯТЬ методы родительского класса (4.2)
		и должны содержать в своём теле вызов библиотеки Math и возврат полученного результата .
	4.4 Создать класс CalculatorWithMathExtendsMain в котором будет точка входа (main метод).
	В main методе требуется создать экземпляр калькулятора
	и используя методы из данного экземпляра посчитать выражения из задания 1. Вывести в консоль результат.
>> simple.CalculatorWithMathExtends
>> runners.CalculatorWithMathExtendsMain

5. Создать класс CalculatorWithCounterClassic.
	5.1 Все методы объявленные в данном классе НЕ статические (не имеют модификатор static).
	5.2 Данный класс должен наследовать класс CalculatorWithMathExtends.
	5.3 В классе должен быть метод void incrementCountOperation()
	который должен увеличивать внутренний счётчик (поле) в калькуляторе.
	5.4 В классе должен быть метод long getCountOperation()
	который должен возвращать количество использований данного калькулятора (поле).
	5.5 Создать класс CalculatorWithCounterClassicMain в котором будет точка входа (main метод).
	В main методе требуется создать экземпляр калькулятора
	и используя методы из данного экземпляра посчитать выражения из задания 1,
	при каждой математической операции самостоятельно вызывать метод incrementCountOperation() для увеличения счётчика.
	Вывести в консоль результат.
>> additional.CalculatorWithCounterClassic
>> runners.CalculatorWithCounterClassicMain

6. Создать класс CalculatorWithCounterAutoSuper.
	6.1 Все методы и поля объявленные в данном классе НЕ статические (не имеют модификатор static).
	6.2 Данный класс наследует класс CalculatorWithMathExtends.
	6.3 Данный класс переопределяет все методы полученные в результате наследования
	и в этих методах должен быть реализован механизм учёта их использования (учёт общий для всех методов класса),
	а вместо реализации математики при помощи ключевого слова super вызывает данный метод у родителя.
	Например вызвали метод plus(7, 3) который должен сложить два числа и вернуть результат сложения.
	Внутри метода plus() пишем реализацию учета, а после делаем вызов super.plus(7, 3).
	Использование super позволит вызвать реализацию из родительского класса.
	6.4 В классе должен быть метод long getCountOperation()
	который должен возвращать количество использований данного калькулятора.
	При вызове данного метода счётчик учёта не увеличивается.
	6.5 Создать класс CalculatorWithCounterAutoSuperMain в котором будет точка входа (main метод).
	В main методе требуется создать экземпляр калькулятора
	и используя методы из данного экземпляра посчитать выражения из задания 1.
	Вывести в консоль результаты посчитанных выражений и результат метода getCountOperation().
>> additional.CalculatorWithCounterAutoSuper
>> runners.CalculatorWithCounterAutoSuperMain

7. Создать класс CalculatorWithCounterAutoComposite и CalculatorWithCounterAutoAgregation.
	7.1 Все методы объявленные в данных классах НЕ статические (не имеют модификатор static).
	7.2 Внутри класса CalculatorWithCounterAutoComposite мы должны создать поле
	хранящее объект класса калькулятор и инициализировать данное поле созданным (использовать new)
	внутри данного класса объектом калькулятора.
	7.3 Внутри класса CalculatorWithCounterAutoAgregation нельзя создавать объекты (использовать new),
	можно пользоваться только тем что передал вам другой программист при использовании вашего класса в конструктор.
		7.3.1 В данном классе должны быть следующие варианты конструктора:
			7.3.1.1 Принимающий объект типа CalculatorWithOperator
			7.3.1.2 Принимающий объект типа CalculatorWithMathCopy
			7.3.1.3 Принимающий объект типа CalculatorWithMathExtends
	7.4 Данные классы напрямую не умеет считать математику,
	они умеет делегировать расчёт математики другим калькуляторам которые сохранены в полях.
	7.5 В классах должны присутствовать математические методы:
		7.5.1 4 базовых математических метода (деление, умножение, вычитание, сложение).
		7.5.2 3 метода (Возведение в целую степень дробного положительного числа, Модуль числа, Корень из числа).
	7.6 В классах созданных в этом задании должен быть метод long getCountOperation()
	который должен возвращать количество использований данного калькулятора.
	При вызове данного метода счётчик учёта не увеличивается.
	7.7 Создать класс CalculatorWithCounterDelegateMain в котором будет точка входа (main метод).
	В main методе требуется создать экземпляры калькуляторов созданных из классов из этого задания
	и используя методы из экземпляра посчитать выражения из задания 1.
	Вывести в консоль результаты посчитанных выражений и результат метода getCountOperation().
>> additional.CalculatorWithCounterAutoComposite
>> additional.CalculatorWithCounterAutoAgregation
>> runners.CalculatorWithCounterDelegateMain

8. Создать интерфейс ICalculator. Данный интерфейс создайте в пакете calcs.api.
	8.1 В данном интерфейсе должны быть объявлены методы:
		8.1.1 4 базовых математических метода (деление, умножение, вычитание, сложение).
		8.1.2 3 метода (Возведение в целую степень дробного положительного числа, Модуль числа, Корень из числа).
	8.2 На данный момент данный интерфейс вы должны прописать во всех классах калькуляторов созданных нами
	в пакетах calcs.simple.
>> api.ICalculator

Данный интерфейс позволит использовать композицию так чтобы это всё-таки было удобно.

9. Создать класс CalculatorWithCounterAutoAgregationInterface.
	9.1 Внутри класса нельзя создавать объекты (использовать new),
	можно пользоваться только тем что передал вам пользователь вашего класса.
	9.2 Все методы объявленные в данном классе НЕ статические (не имеют модификатор static).
	9.3 В данном классе должен быть только конструктор принимающий объект типа ICalculator
	9.4 Данный класс напрямую не умеет считать математику,
	он умеет делегировать расчёт математики другим калькуляторам переданным в конструктор
	9.5 В классе должны присутствовать все методы объявленные в интерфейсе.
	9.6 В классе должен быть метод long getCountOperation()
	который должен возвращать количество использований данного калькулятора.
	При вызове данного метода счётчик учёта не увеличивается.
	9.7 Создать класс CalculatorWithCounterAutoCompositeInterfaceMain в котором будет точка входа (main метод).
	В main методе требуется создать экземпляр калькулятора
	и используя методы из данного экземпляра посчитать выражения из задания 1.
	Вывести в консоль результаты посчитанных выражений и результат метода getCountOperation().
>> additional.CalculatorWithCounterAutoAgregationInterface
>> runners.CalculatorWithCounterAutoCompositeInterfaceMain

10*. Создать CalculatorWithMemory.
	10.1 Данный калькулятор предназначен для того чтобы расширить возможности калькулятора
	и обеспечить его дополнительной функцией памяти. В принципе работает как калькулятор из реальной жизни.
	10.2 Все методы объявленные в данном классе НЕ статические (не имеют модификатор static).
	10.3 Данный класс напрямую не умеет считать математику.
	10.4 В классе должны присутствовать математические методы:
		10.4.1 4 базовых математических метода (деление, умножение, вычитание, сложение).
		10.4.2 3 метода (Возведение в целую степень дробного положительного числа, Модуль числа, Корень из числа).
	10.5 Функция памяти работает через методы:
		10.5.1 Записать в память результат выполнения последнего вызванного метода.
		У данного метода не должно быть параметров. Данный метод вызывается непосредтвенно пользователем, а не автоматический.
		10.5.2 Получить из памяти записанное значение. При получении записи из памяти память стирается,
		при записи нового значения память перезаписывается. Данный метод вызывается непосредтвенно пользователем, а не автоматический.
	10.6 Создать класс CalculatorWithMemoryMain в котором будет точка входа (main метод).
	В main методе требуется создать экземпляр калькулятора
	и используя методы из данного экземпляра посчитать выражения из задания 1.
	Вывести в консоль результат. В мэйне запрещается использование переменных для хранения значений участвующих
	в просчёте, а также результатов работы методов калькулятора, можно использовать только литералы
	и метод получения из памяти записанного значения.

11*. Создать класс CalculatorWithCounterAutoDecorator и CalculatorWithMemoryDecorator
	11.1 Отличие от предыдущих CalculatorWithCounterAutoAgregationInterface и CalculatorWithMemory в том
	что данные классы реализуют интерфейс ICalculator.
	11.2 Данный подход позволяет назвать данный классы "Декораторами".
	Декоратор - это популярный паттерн который позволяет комбинировать и дополнять новыми возможностями объекты
	(в нашем случае калькуляторы) не меняя код в их классе. Тем самым мы приходим к тому
	что мы не наследуем классы для их расширения и не привязываемся к реализации конкретного калькулятора.
	11.3 О декораторах можно прочитать по ссылкам:
		11.3.1 https://refactoring.guru/ru/design-patterns/decorator
		11.3.2 https://www.wikiwand.com/ru/%D0%94%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
	11.4 Добавить в эти классы метод ICalculator getCalculator() который будут возвращать вложенный в них калькулятор.
	11.5 Создать класс CalculatorDecoratorMain в котором будет точка входа (main метод).
	Cоздать переменную типа ICalculator записав в неё новый экземпляр класса CalculatorWithCounterAutoDecorator
	которому в конструктор был передан новый экземпляр класса CalculatorWithMemoryDecorator
	которому в конструтор был передан новый экземпляр класса CalculatorWithMathExtends.
	Используя созданную переменную посчитать выражения из задания 1.
	11.6 Вывести в консоль результат. Вывести количество использований калькулятора.
	Вывести последнее сохранённое значение в памяти. Поможет выполнить instanceof